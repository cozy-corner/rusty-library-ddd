# プロジェクト全体のPhase構成

## Phase分けの方針

### 段階的に学習する

各Phaseで新しい概念を1つずつ追加していく。

### コンテキストごとに完結させる

各Phaseで1つのコンテキストを完成させる。

### 統合は後から

まず独立したコンテキストを作り、後で統合する。

---

## Phase 1: 貸出管理コンテキスト

### 目的

関数型DDDとイベントソーシングの基礎を学ぶ。

### スコープ

**実装するもの：**
- 貸出管理コンテキスト（完全実装）
  - Loan集約
  - イベントソーシング（PostgreSQLイベントストア）
  - CQRS（PostgreSQL Read Model）
  - REST API

**他コンテキストへの依存（ポート定義 + モック実装）：**

- **会員管理への依存ポート（trait MemberService）:**
  - `exists(member_id) -> bool`
  - Phase 1実装：モック実装（常に `true` を返す）
  - 意味：どんな会員IDでも「存在する」と仮定
  
- **カタログ管理への依存ポート（trait BookService）:**
  - `is_available_for_loan(book_id) -> bool`
  - `get_book_title(book_id) -> String`
  - Phase 1実装：モック実装
    - `is_available_for_loan` → 常に `true`
    - `get_book_title` → `"Book {book_id}"`
  - 意味：どんな書籍IDでも「貸出可能」と仮定
  
- **通知サービスへの依存ポート（trait NotificationService）:**
  - `send_overdue_notification(member_id, message) -> ()`
  - Phase 1実装：モック実装（ログ出力のみ）
  - 意味：実際の通知は送信せず、ログに記録

**実装しないもの：**
- 予約管理コンテキスト
- 会員管理コンテキストの実装
- カタログ管理コンテキストの実装
- 職員管理コンテキスト
- コンテキスト間の統合

**動作確認方法：**
- curl, Postman等でREST APIを呼び出し
- フロントエンドは実装しない（Phase外）

### 学習内容

- 純粋関数によるドメインモデル
- イミュータブルなデータ構造
- イベントソーシング（fold/reduce）
- CQRS
- ヘキサゴナルアーキテクチャ
- ポート&アダプター
- コンテキスト境界の設計

### 成果物

- 動作する貸出管理システム
- イベントストア（PostgreSQL）
- Read Model（PostgreSQL）
- REST API
- ポート定義（trait）3つ
- モック実装3つ

---

## Phase 2: 予約管理コンテキスト

### 目的

複数の状態遷移を持つコンテキストを実装する。Phase 1のパターンを応用する。

### スコープ

**実装するもの：**
- 予約管理コンテキスト（完全実装）
  - Reservation集約
  - イベントソーシング（PostgreSQLイベントストア）
  - CQRS（PostgreSQL Read Model）
  - REST API

**他コンテキストへの依存（ポート定義 + モック実装）：**

- **会員管理への依存ポート（trait MemberService）:**
  - `exists(member_id) -> bool`
  - Phase 2実装：モック実装（常に `true` を返す）

- **カタログ管理への依存ポート（trait BookService）:**
  - `exists(book_id) -> bool`
  - `is_available_for_reservation(book_id) -> bool`
  - `get_book_title(book_id) -> String`
  - Phase 2実装：モック実装（すべて成功を返す）

**実装しないもの：**
- 貸出管理との統合イベント（Phase 3で実装）
- 予約確定の自動化（Phase 3で実装）
- 会員管理コンテキストの実装
- カタログ管理コンテキストの実装

**動作確認方法：**
- curl, Postman等でREST APIを呼び出し

**重要な設計判断：**
- 貸出管理コンテキストには直接依存しない
- BookServiceポートを通じてカタログ管理に問い合わせる想定
- Phase 3でイベント駆動により協調する

### 学習内容

- 関数型DDDパターンの応用
- より複雑な状態遷移の実装
- Phase 1のパターンの再確認
- コンテキストの独立性
- ポート設計の重要性

### 成果物

- 動作する予約管理システム
- 2つの独立したコンテキスト
  - 貸出管理
  - 予約管理
- ポート定義（trait）2つ
- モック実装2つ

---

## Phase 3: コンテキスト統合

### 目的

イベント駆動によるコンテキスト間の協調を学ぶ。

### スコープ

**実装するもの：**
- 統合イベント
  - BookReturned（貸出管理が発行）→ 予約管理が購読
  - 予約管理：最優先の予約を自動確定
- イベントハンドラー
- イベントバス（シンプルなインプロセス実装）

**変更するもの：**
- 貸出管理：統合イベントを発行
- 予約管理：統合イベントを購読・処理

**他コンテキストへの依存（ポート）：**
- 会員管理への依存ポート → 引き続きモック実装
- カタログ管理への依存ポート → 引き続きモック実装
- 通知サービスへの依存ポート → 引き続きモック実装

**実装しないもの：**
- 会員管理コンテキストの実装
- カタログ管理コンテキストの実装
- 本格的なメッセージブローカー（Kafka等）

**動作確認方法：**
- 貸出返却後、予約が自動確定されることをAPIで確認

**重要な設計判断：**
- コンテキスト間の協調はイベント経由のみ
- アプリケーションサービスの直接呼び出しはしない
- 疎結合を保つ

### 学習内容

- イベント駆動アーキテクチャ
- コンテキスト間の疎結合な協調
- 統合イベントの設計
- 結果整合性
- ポート設計の効果（依存を最小化）

### 成果物

- 統合された貸出・予約システム
- 書籍返却時に自動的に予約確定
- イベント駆動の協調パターン

---

## Phase 4: サブドメイン実装

### 目的

Phase 1-3で定義したポートの実装を、モックからHTTPアダプターに置き換える。ポート設計の効果を実感する。

### スコープ

**実装するもの：**

- **会員管理コンテキスト（基本機能）:**
  - Member集約
  - CRUD操作（イベントソーシングなし）
  - PostgreSQLデータベース
  - REST API

- **カタログ管理コンテキスト（基本機能）:**
  - Book集約
  - CRUD操作（イベントソーシングなし）
  - PostgreSQLデータベース
  - REST API

**置き換えるポートの実装：**

- **会員管理への依存ポート（trait MemberService）の実装切り替え:**
  - Phase 1-3：モック実装（常に `true`）
  - Phase 4：HTTPアダプター実装
    - `exists(member_id)` → 会員管理APIに HTTPリクエスト `GET /members/{id}`
    - レスポンス200 → `true`、404 → `false`

- **カタログ管理への依存ポート（trait BookService）の実装切り替え:**
  - Phase 1-3：モック実装（常に `true`）
  - Phase 4：HTTPアダプター実装
    - `is_available_for_loan(book_id)` → カタログ管理APIに HTTPリクエスト
    - `get_book_title(book_id)` → カタログ管理APIに HTTPリクエスト

**実装しないもの：**
- 会員管理・カタログ管理のイベントソーシング（不要）
- 複雑なビジネスロジック（CRUDで十分）
- 職員管理コンテキスト
- 本格的な通知機能の実装
- gRPC（Phase 5で実装）

**動作確認方法：**
- 実際の会員データ、書籍データを使用してAPIで確認

**重要な設計判断：**
- ポート（trait）は変更しない
- アダプターの実装だけを切り替える
- アプリケーションサービスのコードは変更不要
- 依存性注入で切り替え

### 学習内容

- アダプターの実装切り替え
- HTTP経由のコンテキスト統合
- マイクロサービスアーキテクチャの基礎
- ポート設計の効果を実感（実装を自由に切り替え可能）

### 成果物

- 完全に動作する図書館システム
- 4つのコンテキスト
  - 貸出管理（Core Domain）
  - 予約管理（Core Domain）
  - 会員管理（Sub Domain）
  - カタログ管理（Sub Domain）
- すべて実際のデータを使用
- HTTPアダプター実装

---

## Phase 5: gRPC通信への切り替え

### 目的

HTTPアダプターをgRPCアダプターに置き換え、ポート設計の効果を再確認する。

### スコープ

**実装するもの：**

- **gRPCサーバー:**
  - 会員管理：gRPC API
  - カタログ管理：gRPC API
  - .protoファイルの定義

- **gRPCアダプター:**
  - MemberServiceのgRPC実装
  - BookServiceのgRPC実装

**置き換えるもの：**
- HTTPアダプター → gRPCアダプター
  - Phase 4：HTTP通信
  - Phase 5：gRPC通信

**変更しないもの：**
- ポート（trait）定義
- アプリケーションサービス
- ドメイン層
- REST API（貸出管理、予約管理）

**実装しないもの：**
- フロントエンド（Phase外）
- 本格的な通知機能

**動作確認方法：**
- Phase 4と同じ動作をgRPC経由で確認
- HTTPとgRPCのパフォーマンス比較（オプション）

**重要な設計判断：**
- ポート（trait）は全く変更しない
- アプリケーションサービスのコードは1行も変更しない
- main.rsの依存性注入だけを変更
- これがポート&アダプターの真価

### 学習内容

- gRPCの基礎
- .protoファイルの設計
- HTTPとgRPCの違い
- ポート設計の効果を再確認（2回目の実装切り替え）
- アーキテクチャの柔軟性

### 成果物

- gRPC対応の図書館システム
- HTTPとgRPC両方をサポート可能な設計
- .protoファイル
- gRPCアダプター実装

---

## Phase 6以降（オプション）

### 技術的な改善

- 認証・認可
- トランザクション管理の強化
- パフォーマンス最適化
- スナップショット（イベントソーシング）
- イベントバージョニング

### 機能追加

- 職員管理コンテキスト
- レポート機能
- 統計機能
- 実際の通知機能（メール、SMS）

### アーキテクチャ進化

- 本格的なイベントバス（Kafka, RabbitMQ）
- CQRS読み込み側の最適化
- 分散トレーシング
- サービスメッシュ

---

## フロントエンド（Phase外）

### 位置づけ

フロントエンドは別プロジェクトとして扱う。

**理由：**
- バックエンドの学習に集中
- DDDとイベントソーシングが学習の中心
- フロントエンドは技術選定の自由度が高い

### 実装する場合

**推奨技術スタック：**
- React / Vue / Svelte（好みで選択）
- TypeScript
- REST API経由でバックエンドと通信

**機能：**
- 貸出管理画面
- 予約管理画面
- 会員管理画面
- カタログ管理画面

**別リポジトリ推奨：**
- バックエンド：`rusty-library-backend`
- フロントエンド：`rusty-library-frontend`

---

## Phaseごとの依存関係

### Phase 1: 貸出管理
- 独立して完成
- ポート定義（trait MemberService, BookService, NotificationService）
- モック実装

### Phase 2: 予約管理
- 独立して完成
- ポート定義（trait MemberService, BookService）
- モック実装
- Phase 1とは独立（直接依存しない）

### Phase 3: コンテキスト統合
- Phase 1を変更：統合イベントを発行
- Phase 2を変更：統合イベントを購読・処理
- イベント駆動で協調

### Phase 4: サブドメイン実装（HTTP）
- Phase 1のポート実装を置き換え：モック → HTTP
- Phase 2のポート実装を置き換え：モック → HTTP
- Phase 3（統合）はそのまま
- 会員管理コンテキストを実装
- カタログ管理コンテキストを実装

### Phase 5: gRPC通信
- Phase 4のHTTPアダプターをgRPCアダプターに置き換え
- ポート（trait）は変更なし
- アプリケーションサービスは変更なし
- 依存性注入の部分だけ変更

---

## フロー図

```
Phase 1
  ↓
Phase 2（Phase 1と並行可能）
  ↓
Phase 3（Phase 1, 2を統合）
  ↓
Phase 4（Phase 1, 2のアダプター置き換え）
  ↓
Phase 5（Phase 4のアダプター置き換え）
```

---

## 各Phaseでの変更範囲

| Phase | 貸出管理 | 予約管理 | 会員管理 | カタログ管理 |
|-------|---------|---------|---------|------------|
| 1 | 実装 | - | ポート定義のみ | ポート定義のみ |
| 2 | - | 実装 | ポート定義のみ | ポート定義のみ |
| 3 | イベント発行追加 | イベント購読追加 | ポート定義のみ | ポート定義のみ |
| 4 | アダプター置き換え | アダプター置き換え | 実装 | 実装 |
| 5 | アダプター置き換え | アダプター置き換え | gRPC追加 | gRPC追加 |

---

## Phase構成の利点

### 1. 段階的な学習

各Phaseで新しい概念を1つずつ追加。

### 2. 早期の成果

Phase 1で動くシステムができる。

### 3. 柔軟な中断

Phase 2以降は必要に応じて実施。

### 4. 設計の検証

Phase 1-2で設計を検証してから統合。

### 5. ポート設計の効果を複数回実感

- Phase 4: モック → HTTP
- Phase 5: HTTP → gRPC

アプリケーションサービスは変更不要。

---

## ポート&アダプターの全体像

```
【アプリケーションサービス】
LoanService（貸出管理）
ReservationService（予約管理）
    ↓ 依存
【ポート（trait）】
MemberService
BookService
NotificationService
    ↓ 実装
【アダプター】
Phase 1-3: モック実装
Phase 4: HTTP実装
Phase 5: gRPC実装
```

**重要：**
- アプリケーションサービスはポート（trait）に依存
- ポートの実装（アダプター）を切り替えても、アプリケーションサービスは変更不要
- Phase 4とPhase 5で2回この効果を実感

---

## まとめ

**Phase 1-2：独立したコンテキスト**
- 関数型DDD
- イベントソーシング
- ポート定義 + モック実装

**Phase 3：コンテキスト統合**
- イベント駆動
- 疎結合な協調

**Phase 4：サブドメイン実装（HTTP）**
- ポート実装の切り替え（モック → HTTP）
- システム完成

**Phase 5：gRPC通信**
- ポート実装の再切り替え（HTTP → gRPC）
- アーキテクチャの柔軟性を実感

**フロントエンド：Phase外**
- 別プロジェクトとして実装
- 技術選定の自由度
